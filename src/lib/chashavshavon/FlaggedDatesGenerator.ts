// FlaggedDatesGenerator - Core calculation engine for generating flagged dates (Zmanei Shemira)
import { jDate } from 'jcal-zmanim';
import { NightDay } from './Onah';
import Kavuah, { KavuahTypes } from './Kavuah';
import { ProblemFlag, ProblemOnah } from './ProblemOnah';
import Entry from './Entry';
import { Settings } from '@/types';

/**
 * This class is used to Generate Problem Onahs (Flagged Dates / Zmanei Shemira) from
 * a list of Entries, a list of Kavuahs and a Settings object.
 * 
 * Usage: new FlaggedDatesGenerator(entries, kavuahs, settings).getProblemOnahs()
 * 
 * This implements all the Halachic rules for determining which dates require restrictions.
 */
export default class FlaggedDatesGenerator {
    private entries: Entry[];
    private settings: Settings;
    private kavuahs: Kavuah[];
    private cancelKavuah?: Kavuah;
    private probOnahs: ProblemOnah[];
    private stopWarningDate: jDate;

    /**
     * Create a new FlaggedDatesGenerator
     * @param entries List of entries (periods)
     * @param kavuahs List of kavuahs (patterns)
     * @param settings Halachic settings
     */
    constructor(entries: Entry[], kavuahs: Kavuah[], settings: Settings) {
        this.entries = entries;
        this.settings = settings;
        // Only include active, non-ignored Kavuahs
        this.kavuahs = (kavuahs && kavuahs.filter(k => k.active && !k.ignore)) || [];
        // Find the Kavuah that cancels Onah Beinonis
        this.cancelKavuah = kavuahs.find(k => k.active && k.cancelsOnahBeinunis);
        this.probOnahs = [];
        this.stopWarningDate = new jDate().addMonths(settings.numberMonthsAheadToWarn);
    }

    /**
     * Gets the list of Onahs that need to be observed (Zmanei Shemira).
     * Problem Onahs are searched for from the date of each entry
     * until the number of months specified in the setting "numberMonthsAheadToWarn"
     * @returns Array of ProblemOnah objects sorted chronologically
     */
    getProblemOnahs(): ProblemOnah[] {
        // Clean the list
        this.probOnahs = [];

        // Find Flagged Dates that need to be calculated from the list of Entries
        for (const entry of this.entries) {
            this._findOnahBeinunisProblemOnahs(entry, this.cancelKavuah);
            // Get problems generated by active Kavuahs
            this._findEntryDependentKavuahProblemOnahs(entry);
        }

        // Get the onahs that need to be kept for Kavuahs of Yom Hachodesh, Sirug,
        // and other Kavuahs that are not dependent on the actual entry list
        this._findIndependentKavuahProblemOnahs();

        // Sort the problem list and return it
        return ProblemOnah.sortProbList(this.probOnahs);
    }

    /**
     * Find Onah Beinonis (30-day cycle) problem onahs for a given entry.
     * This includes:
     * - Yom Hachodesh (same day of Jewish month)
     * - Day 30
     * - Day 31 (if setting enabled)
     * - Haflaga (interval from previous entry)
     * - Haflaga of Onahs (if setting enabled)
     * - Longer Haflagas that were never overridden (Ta"z, if setting enabled)
     */
    private _findOnahBeinunisProblemOnahs(entry: Entry, cancelKavuah?: Kavuah): void {
        // Yom Hachodesh ***************************************************************
        const nextMonth = entry.date.addMonths(1);
        // If Yom Hachodesh was 30 and this month only has 29 days,
        // the 29th and the 1st should both be flagged.
        // In the above scenario, jdate.addMonths will automatically change the Day to 29.
        const hasFullMonthIssue = entry.date.Day === 30 && nextMonth.Day === 29;

        if (!isAfterKavuahStart(nextMonth, entry.nightDay, cancelKavuah)) {
            const yomHachodesh = new ProblemFlag(
                nextMonth,
                entry.nightDay,
                'Yom Hachodesh' + (hasFullMonthIssue ? ' (changed from 30 to 29)' : '')
            );
            this._addProblem(yomHachodesh);
            this._add24HourOnah(yomHachodesh);
            // We won't flag the Ohr Zarua if it's included in Onah Beinonis
            // of 24 hours as Onah Beinonis is stricter.
            if (!this.settings.onahBeinunis24Hours || entry.nightDay === NightDay.Night) {
                this._addOhrZarua(yomHachodesh);
            }
        }

        // If Yom Hachodesh was 30 and this month only has 29 days, we add the 1st of the next month
        if (hasFullMonthIssue) {
            const nextDay = nextMonth.addDays(1);
            if (!isAfterKavuahStart(nextDay, entry.nightDay, cancelKavuah)) {
                const yomHachodesh_2 = new ProblemFlag(
                    nextDay,
                    entry.nightDay,
                    'Yom Hachodesh (changed from 30 to 1)'
                );
                this._addProblem(yomHachodesh_2);
                this._add24HourOnah(yomHachodesh_2);
                if (!this.settings.onahBeinunis24Hours || entry.nightDay === NightDay.Night) {
                    this._addOhrZarua(yomHachodesh_2);
                }
            }
        }

        // Day Thirty ***************************************************************
        // We only need to add 29 days as the entry date is day one
        const dayThirty = entry.date.addDays(29);
        if (!isAfterKavuahStart(dayThirty, entry.nightDay, cancelKavuah)) {
            const thirty = new ProblemFlag(dayThirty, entry.nightDay, 'Thirtieth Day');
            this._addProblem(thirty, entry);
            this._add24HourOnah(thirty, entry);
            if (!this.settings.onahBeinunis24Hours || entry.nightDay === NightDay.Night) {
                this._addOhrZarua(thirty, entry);
            }
        }

        // Day Thirty One ***************************************************************
        if (this.settings.keepThirtyOne) {
            const dayThirtyOne = dayThirty.addDays(1);
            if (!isAfterKavuahStart(dayThirtyOne, entry.nightDay, cancelKavuah)) {
                const thirtyOne = new ProblemFlag(dayThirtyOne, entry.nightDay, 'Thirty First Day');
                this._addProblem(thirtyOne, entry);
                this._add24HourOnah(thirtyOne, entry);
                if (!this.settings.onahBeinunis24Hours || entry.nightDay === NightDay.Night) {
                    this._addOhrZarua(thirtyOne, entry);
                }
            }
        }

        // Haflagah **********************************************************************
        const haflagaDate = entry.date.addDays(entry.haflaga - 1);
        if (entry.haflaga > 0 && !isAfterKavuahStart(haflagaDate, entry.nightDay, cancelKavuah)) {
            const haflaga = new ProblemFlag(
                haflagaDate,
                entry.nightDay,
                `Yom Haflagah (of ${entry.haflaga.toString()} days)`
            );
            // Note the Haflaga is always just the Onah it occurred on - not 24 hours -
            // even according to those that require it for 30, 31 and Yom Hachodesh.
            this._addProblem(haflaga, entry);
            this._addOhrZarua(haflaga, entry);
        }

        // Haflagah of Onahs *************************************************************
        if (this.settings.haflagaOfOnahs) {
            const prevEntry = this.entries[this.entries.indexOf(entry) - 1];
            // If they have the same nightDay then it will be a regular haflaga
            if (prevEntry && prevEntry.nightDay !== entry.nightDay) {
                const diffOnahs = prevEntry.getOnahDifferential(entry);
                const nextOnah = entry.onah.addOnahs(diffOnahs);
                if (!isAfterKavuahStart(nextOnah.jdate, nextOnah.nightDay, cancelKavuah)) {
                    const haflagaOnahs = new ProblemFlag(
                        nextOnah.jdate,
                        nextOnah.nightDay,
                        `Haflagah of Onahs (of ${diffOnahs.toString()} onahs)`
                    );
                    this._addProblem(haflagaOnahs);
                    this._addOhrZarua(haflagaOnahs);
                }
            }
        }

        // The Ta"z - Keep longer Haflagas that were never overridden
        if (this.settings.keepLongerHaflagah) {
            const probs: ProblemFlag[] = [];
            // Go through all earlier entries in the list that have a longer haflaga than this one
            // and that are not kept anyway due to onah beinonis
            for (const e of this.entries.filter(
                en =>
                    en.abs < entry.abs &&
                    en.haflaga > entry.haflaga &&
                    en.haflaga !== 30 &&
                    (en.haflaga !== 31 || !this.settings.keepThirtyOne)
            )) {
                // See if their haflaga was never surpassed by an Entry after them
                if (!this.entries.some(oe => oe.abs > e.abs && oe.haflaga > e.haflaga)) {
                    const haflagaDate = entry.date.addDays(e.haflaga - 1);
                    if (!isAfterKavuahStart(haflagaDate, entry.nightDay, cancelKavuah)) {
                        const nonOverrided = new ProblemFlag(
                            haflagaDate,
                            entry.nightDay,
                            'Yom Haflaga (' + e.haflaga.toString() + ' days) which was never overrided'
                        );
                        // As there can be more than single longer haflaga'd Entry with the same haflaga,
                        // we want to prevent doubles
                        if (!probs.some(p => p.isSameProb(nonOverrided))) {
                            probs.push(nonOverrided);
                        }
                    }
                }
            }
            for (const prob of probs) {
                this._addProblem(prob);
                this._addOhrZarua(prob);
            }
        }
    }

    /**
     * Find problem onahs generated by Kavuahs that depend on actual entries.
     * This includes:
     * - Kavuah Haflaga
     * - Kavuah Dilug Haflaga
     * - Kavuah Haflaga of Onahs
     */
    private _findEntryDependentKavuahProblemOnahs(entry: Entry): void {
        // Kavuah Haflagah - with or without Maayan Pasuach
        for (const kavuah of this.kavuahs.filter(k =>
            [KavuahTypes.Haflagah, KavuahTypes.HaflagaMaayanPasuach].includes(k.kavuahType)
        )) {
            const haflagaDate = entry.date.addDays(kavuah.specialNumber - 1);
            const kavuahHaflaga = new ProblemFlag(
                haflagaDate,
                kavuah.settingEntry.nightDay,
                'Kavuah of ' + kavuah.toString()
            );
            this._addProblem(kavuahHaflaga);
            this._addOhrZarua(kavuahHaflaga);
        }

        // Kavuah of Dilug Haflaga
        // They are cheshboned from actual entries - not theoretical ones
        for (const kavuah of this.kavuahs.filter(
            k => k.kavuahType === KavuahTypes.DilugHaflaga && k.active
        )) {
            /* The logic here is to count the number of entries since the 
            setting entry and calculate the dilug for each one - 
            whether or not there was an actual entry on that date.
            Using this logic to calculate this type of kavuah causes that 
            if the entry haflagas were: 5, 7, 9, 10, we will flag the 13th day from the entry of 10 not the 11th day. 
            We assume that the haflagah of 10 was "instead" of the 11, and not an unrelated entry with the 11 still to come.
            בדי השולחן קפ"ט סעיף ה' ביאורים ד"ה לדילוג של הפלגות בשם המקור חיים
            Rav Feivel Cohen Shlit"a (סוף דבריו שם) is mesupak if there was 5, 7, 9, 8 if the next one is 11 or 9 - 
            since she didn't pass the 9th day without an Entry.
            According to the logic below, we are not flagging this scenario. וצ"ע.
            */
            const settingEntry = kavuah.settingEntry;
            const numEntriesSinceSetting = this.entries.filter(
                e => e.abs >= settingEntry.abs && e.abs <= entry.abs
            ).length;
            const dilugCurrent = numEntriesSinceSetting * kavuah.specialNumber;
            const calculatedHaflaga = settingEntry.haflaga + dilugCurrent;
            const haflagaDate = entry.date.addDays(calculatedHaflaga - 1);
            const kavuahDilugHaflaga = new ProblemFlag(
                haflagaDate,
                kavuah.settingEntry.nightDay,
                'Kavuah of ' + kavuah.toString()
            );
            this._addProblem(kavuahDilugHaflaga);
            this._addOhrZarua(kavuahDilugHaflaga);
        }

        // Flagged Dates generated by Kavuahs of Haflagah by Onahs - the Shulchan Aruch Harav
        for (const kavuah of this.kavuahs.filter(k => k.kavuahType === KavuahTypes.HafalagaOnahs)) {
            const haflagaOnah = entry.onah.addOnahs(kavuah.specialNumber);
            const kavuahHafOnahs = new ProblemFlag(
                haflagaOnah.jdate,
                haflagaOnah.nightDay,
                'Kavuah of ' + kavuah.toString()
            );
            this._addProblem(kavuahHafOnahs);
            this._addOhrZarua(kavuahHafOnahs);
        }
    }

    /**
     * Find problem onahs generated by "Independent" Kavuahs.
     * These are Kavuahs that are calculated from theoretical entries, not actual ones.
     * Includes: Yom Hachodesh, Sirug, Day of Week, Dilug Day of Month
     */
    private _findIndependentKavuahProblemOnahs(): void {
        // "Independent" Kavuahs which are cheshboned from the theoretical Entries
        for (const kavuah of this.kavuahs.filter(k => k.isIndependent)) {
            const iters = Kavuah.getIndependentIterations(
                kavuah,
                this.stopWarningDate,
                this.settings.dilugChodeshPastEnds
            );
            for (const onah of iters) {
                const problemFlag = new ProblemFlag(
                    onah.jdate,
                    onah.nightDay,
                    'Kavuah for ' + kavuah.toString()
                );
                this._addProblem(problemFlag);
                this._addOhrZarua(problemFlag);
            }
        }
    }

    /**
     * Add the opposite onah (24-hour period) if the setting is enabled.
     * For example, if the problem is on day, also flag the night.
     */
    private _add24HourOnah(prob: ProblemFlag, entry?: Entry): void {
        if (this.settings.onahBeinunis24Hours) {
            this._addProblem(
                new ProblemFlag(
                    prob.jdate,
                    prob.nightDay === NightDay.Day ? NightDay.Night : NightDay.Day,
                    prob.description + ' (24 hour)'
                ),
                entry
            );
        }
    }

    /**
     * Add the Ohr Zarua (previous onah) if the setting is enabled.
     * The Ohr Zarua is the onah immediately before the flagged onah.
     */
    private _addOhrZarua(prob: ProblemFlag, entry?: Entry): void {
        // If the user wants to keep the Ohr Zarua - the previous onah
        if (this.settings.showOhrZeruah) {
            const ohrZarua = prob.onah.previous;
            this._addProblem(
                new ProblemFlag(ohrZarua.jdate, ohrZarua.nightDay, 'Ohr Zarua of the ' + prob.description),
                entry
            );
        }
    }

    /**
     * Add the given ProblemFlag to the flagsList of the ProblemOnah for the given Onah.
     * If there isn't yet a ProblemOnah for this Onah in this.probOnahs, it will be added.
     * @param probFlag The problem flag to add
     * @param settingEntry Optional entry to pass on to the _canAddFlaggedDate function
     */
    private _addProblem(probFlag: ProblemFlag, settingEntry?: Entry): void {
        if (this._canAddFlaggedDate(probFlag, settingEntry)) {
            let probOnah = this.probOnahs.find(po => po.isSameOnah(probFlag.onah));
            if (!probOnah) {
                probOnah = new ProblemOnah(probFlag.jdate, probFlag.nightDay);
                this.probOnahs.push(probOnah);
            }
            probOnah.flagsList.push(probFlag.description);
        }
    }

    /**
     * Returns false if the noProbsAfterEntry setting is on and there was an Entry
     * in the 7 days before the given flag's onah.
     * Will also return false if the settingEntry is supplied, and keepLongerHaflagah is off,
     * and there was another entry between the settingEntry and the problem onah.
     * This is to prevent flagging haflaga type problems when there were other entries before the problem onah.
     * @param probFlag The problem flag to check
     * @param settingEntry If supplied and the keepLongerHaflagah is off and
     * there was another Entry between the settingEntry and the problem onah,
     * will cause this function to return false
     */
    private _canAddFlaggedDate(probFlag: ProblemFlag, settingEntry?: Entry): boolean {
        const jdate = probFlag.jdate;
        const nightDay = probFlag.nightDay;

        if (
            !this.settings.keepLongerHaflagah &&
            settingEntry &&
            this.entries.some(
                e =>
                    // If there is an Entry in the list that is after the setting entry
                    (e.abs > settingEntry.abs || (e.abs === settingEntry.abs && e.nightDay > settingEntry.nightDay)) &&
                    // and that entry is before the prospective problem onah
                    (e.abs < jdate.Abs || (e.abs === jdate.Abs && e.nightDay < nightDay))
            )
        ) {
            // The problem will not be flagged
            return false;
        }

        if (!this.settings.noProbsAfterEntry) {
            return true;
        } else {
            return !this.entries.some(
                en =>
                    en.abs >= jdate.Abs - 7 &&
                    (en.abs < jdate.Abs || (en.abs === jdate.Abs && en.nightDay < nightDay))
            );
        }
    }
}

/**
 * Returns true if the given date and NightDay are after the setting entry date
 * of the given Kavuah.
 * This is used to determine if a Problem Onah is after the setting entry of
 * a cancelling Kavuah in order to prevent its flagging.
 */
function isAfterKavuahStart(date: jDate, nightDay: NightDay, cancelKavuah?: Kavuah): boolean {
    if (cancelKavuah) {
        const settingEntry = cancelKavuah.settingEntry;
        return (
            !!settingEntry &&
            (date.Abs > settingEntry.abs || (date.Abs === settingEntry.abs && nightDay > settingEntry.nightDay))
        );
    }
    return false;
}
